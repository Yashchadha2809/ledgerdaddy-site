<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chat â€“ Ledgerdaddy</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; width: 100%; }
    /* message animations */
    .fade-in { animation: fade .15s ease-out; }
    @keyframes fade { from { opacity: 0.5; transform: translateY(2px); } to { opacity: 1; transform: none; } }
    .typing-dot { animation: pulse 1s infinite ease-in-out; }
    .typing-dot:nth-child(2) { animation-delay: .15s; }
    .typing-dot:nth-child(3) { animation-delay: .3s; }
    @keyframes pulse { 0%, 80%, 100% { opacity: .25; } 40% { opacity: 1; } }
    /* limit filename truncation on mobile */
    @media (max-width: 768px) {
      .name-wrap { max-width: 50vw; }
    }
  </style>
</head>
<body class="h-full flex flex-col bg-white text-gray-900">
  <!-- Top toolbar -->
  <header class="flex items-center justify-between gap-2 p-3 border-b bg-gray-50">
    <div class="flex items-center gap-2">
      <button id="newChat" class="p-2 border rounded text-sm hover:bg-gray-100" title="New chat">+</button>
      <select id="modelSelect" class="text-sm border rounded px-2 py-1 bg-white">
        <option>Chat model</option>
        <option>GPT-4</option>
        <option>GPT-3.5</option>
      </select>
      <select id="privacySelect" class="text-sm border rounded px-2 py-1 bg-white">
        <option>Private</option>
        <option>Public</option>
      </select>
    </div>
    <!-- Vercel -> Customs Chat (same look) -->
    <a href="#" class="text-xs bg-black text-white px-3 py-1 rounded hover:bg-gray-800">Customs Chat</a>
  </header>

  <div class="flex flex-1 overflow-hidden">
    <!-- Sidebar for conversations -->
    <aside class="hidden md:block w-64 border-r overflow-y-auto p-2">
      <ul id="chatList" class="space-y-1 text-sm"></ul>
    </aside>

    <!-- Chat area -->
    <main class="flex-1 flex flex-col">
      <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-4"></div>
      <!-- Composer -->
      <div class="border-t p-3 bg-white">
        <form id="composer" class="flex items-end gap-2">
          <input id="fileInput" type="file" class="hidden"
            multiple accept="image/*,.pdf,.csv,.txt,.json,.md,.doc,.docx,.xls,.xlsx,.ppt,.pptx" />
          <button id="attachBtn" type="button" class="p-2 rounded hover:bg-gray-100">ðŸ“Ž</button>
          <textarea id="chatInput" rows="1" placeholder="Send a messageâ€¦"
            class="flex-1 border rounded px-3 py-2 resize-none max-h-40 focus:outline-none"></textarea>
          <button id="sendBtn" type="submit"
            class="p-2 bg-blue-600 text-white rounded-full hover:bg-blue-500" aria-label="Send">âž¤</button>
        </form>
      </div>
    </main>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="fixed bottom-5 right-5 hidden text-xs bg-gray-800 text-white px-3 py-2 rounded"></div>

  <script>
    // ====== CONFIG ======
    // Set to your API origin, e.g. "https://chadaddy.onrender.com"
    // Leave empty string '' to call same-origin /api/*
    const API_BASE = '';

    // ====== Session (stable across tabs for this browser) ======
    function uid() { return Math.random().toString(36).slice(2) + Date.now().toString(36); }
    function getSessionId(){
      const k="ld_chat_session_id";
      let v = localStorage.getItem(k);
      if(!v){ v=(crypto?.randomUUID?.() || `sess_${uid()}`); localStorage.setItem(k, v); }
      return v;
    }
    const SESSION_ID = getSessionId();

    // ===== Thread storage and helpers =====
    const STORE_KEY = 'ld_chat_threads_v2';
    let threads = JSON.parse(localStorage.getItem(STORE_KEY) || '[]');
    let currentId = threads[0]?.id || null;
    function getCurrent() { return threads.find(t => t.id === currentId); }
    function saveThreads() { localStorage.setItem(STORE_KEY, JSON.stringify(threads)); }
    function setTitleFromFirstUserMessage(thread) {
      const first = thread.messages.find(m => m.role === 'user');
      if (first) thread.title = (first.text || 'Conversation').slice(0, 50);
    }
    // Toast helper
    const toast = (msg) => {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.remove('hidden');
      setTimeout(() => t.classList.add('hidden'), 1500);
    };

    // ===== Sidebar render =====
    function renderSidebar() {
      const list = document.getElementById('chatList');
      if (!list) return;
      if (!threads.length) {
        list.innerHTML = '<li class="text-gray-500 text-xs p-2 rounded">No conversations yet</li>';
        return;
      }
      list.innerHTML = threads.map(t => `
        <li>
          <button data-id="${t.id}" class="w-full text-left px-2 py-2 rounded hover:bg-gray-100 ${t.id === currentId ? 'bg-gray-200' : ''}">
            <div class="truncate">${t.title || 'Conversation'}</div>
            <div class="text-[11px] text-gray-500">${(t.messages?.length || 0)} messages</div>
          </button>
        </li>
      `).join('');
      list.querySelectorAll('button[data-id]').forEach(btn => {
        btn.onclick = () => {
          currentId = btn.getAttribute('data-id');
          renderSidebar();
          renderMessages();
        };
      });
    }

    // ===== Message rendering =====
    function mdLite(text) {
      let out = (text || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      out = out.replace(/```([\s\S]*?)```/g, (_, code) => `<pre><code>${code}</code></pre>`);
      out = out.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      out = out.replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 py-0.5 rounded text-[90%]">$1</code>');
      out = out.replace(/\n\n/g, '<br/><br/>');
      return out;
    }
    function attachBlock(attachments=[]) {
      if (!attachments.length) return '';
      return `
        <div class="mt-2 flex flex-wrap gap-2">
          ${attachments.map(a => {
            const isImg = /^image\//.test(a.type);
            return isImg
              ? `<a href="${a.url}" target="_blank" class="inline-flex items-center gap-2" title="${a.name || 'image'}">
                   <img src="${a.url}" alt="${a.name || 'image'}" class="h-12 w-12 rounded object-cover" />
                   <span class="text-[12px] truncate name-wrap">${a.name || 'image'}</span>
                 </a>`
              : `<a href="${a.url}" target="_blank" class="border px-2 py-1 rounded text-[12px]" title="${a.name || 'file'}">
                   <span class="truncate name-wrap">${a.name || 'file'}</span>
                 </a>`;
          }).join('')}
        </div>
      `;
    }
    function msgBubble(m) {
      const { role, text, attachments } = m;
      const isUser = role === 'user';
      return `
        <div class="fade-in p-3 rounded-xl ${isUser ? 'bg-blue-50' : 'bg-gray-100'}">
          <div class="text-[12px] text-gray-600 mb-1">${isUser ? 'You' : 'Assistant'}</div>
          ${attachments?.length ? attachBlock(attachments) : ''}
          <div class="whitespace-pre-wrap leading-relaxed text-[15px]">${mdLite(text || '')}</div>
        </div>
      `;
    }
    function renderMessages() {
      const wrap = document.getElementById('messages');
      const t = getCurrent();
      if (!t) {
        wrap.innerHTML = '<div class="p-4 text-gray-500">Start a new chat.</div>';
        return;
      }
      wrap.innerHTML = t.messages.map(msgBubble).join('') ||
        '<div class="p-4 text-gray-500">How can I help you today?</div>';
      wrap.scrollTop = wrap.scrollHeight;
    }
    function addMessage(role, text, attachments=[]) {
      const t = getCurrent(); if (!t) return;
      t.messages.push({ role, text, attachments, ts: Date.now() });
      if (t.title === 'New chat') setTitleFromFirstUserMessage(t);
      saveThreads();
      renderSidebar();
      renderMessages();
    }

    // Temporary typing bubble (same visual style as assistant)
    function showTyping() {
      const wrap = document.getElementById('messages');
      const el = document.createElement('div');
      el.id = 'typing';
      el.className = 'p-3 rounded-xl bg-gray-100';
      el.innerHTML = `
        <div class="text-[12px] text-gray-600 mb-1">Assistant</div>
        <div class="flex items-center gap-1">
          <span class="typing-dot w-2 h-2 rounded-full bg-gray-500"></span>
          <span class="typing-dot w-2 h-2 rounded-full bg-gray-500"></span>
          <span class="typing-dot w-2 h-2 rounded-full bg-gray-500"></span>
        </div>
      `;
      wrap.appendChild(el);
      wrap.scrollTop = wrap.scrollHeight;
    }
    function hideTyping() {
      const el = document.getElementById('typing');
      if (el) el.remove();
    }

    // ===== File attachments =====
    const MAX_FILES = 10;
    const MAX_MB = 25;
    let pendingFiles = [];
    const fileInput = document.getElementById('fileInput');
    const attachBtn = document.getElementById('attachBtn');
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', e => addPendingFiles([...e.target.files]));
    function addPendingFiles(files) {
      for (const f of files) {
        if (pendingFiles.length >= MAX_FILES) { toast('Max 10 files'); break; }
        if (f.size > MAX_MB * 1024 * 1024) { toast(`${f.name} is over ${MAX_MB}MB`); continue; }
        pendingFiles.push({ file: f, id: uid(), url: URL.createObjectURL(f) });
      }
    }
    async function uploadFiles(files) {
      if (!files.length) return [];
      const form = new FormData();
      files.forEach(f => form.append('files', f.file, f.file.name));
      try {
        const res = await fetch(`${API_BASE}/api/upload`, { method:'POST', body: form });
        if (!res.ok) throw new Error('Upload failed');
        const data = await res.json();
        const list = Array.isArray(data) ? data : (data.files || [data]);
        return list.map((x,i) => ({
          url: x.url || files[i].url,
          name: x.name || files[i].file.name,
          type: x.type || files[i].file.type,
          size: x.size || files[i].file.size
        }));
      } catch (e) {
        toast('Upload error: ' + (e.message || 'unknown'));
        return files.map(p => ({ url: p.url, name: p.file.name, type: p.file.type, size: p.file.size }));
      }
    }

    // ===== Backend helpers (JSON + streaming) =====
    async function sendToBackend({ message, attachments }) {
      const res = await fetch(`${API_BASE}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message,
          attachments,
          session_id: SESSION_ID,
          model: document.getElementById('modelSelect')?.value || undefined,
          privacy: document.getElementById('privacySelect')?.value || undefined
        }),
        cache: 'no-store'
      });
      const ct = (res.headers.get('content-type') || '').toLowerCase();

      // Streaming (SSE or raw text)
      if (ct.includes('text/event-stream') || ct.includes('text/plain') || ct.includes('application/octet-stream')) {
        // Start an empty assistant message to append chunks into:
        addMessage('assistant', '');
        const t = getCurrent();
        const msg = t.messages[t.messages.length - 1];
        const reader = res.body?.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        if (!reader) {
          hideTyping();
          addMessage('assistant', 'âš ï¸ Streaming not supported in this browser.');
          return;
        }
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          // Split SSE events by blank line
          const parts = buffer.split(/\r?\n\r?\n/);
          buffer = parts.pop() || '';
          for (const part of parts) {
            const lines = part.split(/\r?\n/).filter(Boolean);
            for (const line of lines) {
              const payload = line.replace(/^data:\s?/, '');
              try {
                const obj = JSON.parse(payload);
                const delta = obj.delta ?? obj.message ?? obj.content ?? '';
                if (delta) { msg.text = (msg.text || '') + delta; saveThreads(); renderMessages(); }
              } catch {
                msg.text = (msg.text || '') + payload;
                saveThreads(); renderMessages();
              }
            }
          }
        }
        // Flush any trailing text
        if (buffer.trim()) {
          try {
            const obj = JSON.parse(buffer);
            const delta = obj.delta ?? obj.message ?? obj.content ?? buffer;
            msg.text = (msg.text || '') + delta;
          } catch {
            msg.text = (msg.text || '') + buffer;
          }
          saveThreads(); renderMessages();
        }
        return;
      }

      // JSON reply
      if (ct.includes('application/json')) {
        const data = await res.json();
        if (res.ok && data.reply) return data.reply;
        throw new Error(data.error || `API ${res.status}`);
      }

      // Fallback: plain text
      const txt = await res.text();
      if (res.ok && txt) return txt;
      throw new Error(txt || `HTTP ${res.status}`);
    }

    // ===== Sending messages =====
    const form = document.getElementById('composer');
    const area = document.getElementById('chatInput');
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = (area.value || '').trim();
      if (!text && !pendingFiles.length) return;
      const uploaded = await uploadFiles(pendingFiles);
      pendingFiles.forEach(p => URL.revokeObjectURL(p.url));
      pendingFiles = [];
      addMessage('user', text, uploaded);
      area.value = '';
      showTyping();
      try {
        const reply = await sendToBackend({ message: text, attachments: uploaded });
        hideTyping();
        if (typeof reply === 'string' && reply.length) {
          addMessage('assistant', reply);
        } else {
          // if streaming handled it, nothing to do
          if (!reply) addMessage('assistant', ''); 
        }
      } catch (err) {
        hideTyping();
        addMessage('assistant', 'Error: ' + (err.message || 'Request failed'));
      }
    });
    area.addEventListener('input', () => {
      area.style.height = 'auto';
      area.style.height = Math.min(area.scrollHeight, 160) + 'px';
    });
    area.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.requestSubmit();
      }
    });

    // ===== New chat =====
    document.getElementById('newChat').addEventListener('click', () => {
      const id = uid();
      threads.unshift({ id, title: 'New chat', messages: [] });
      currentId = id;
      saveThreads();
      renderSidebar();
      renderMessages();
    });

    // ===== Init =====
    if (!threads.length) {
      const id = uid();
      threads = [{ id, title: 'New chat', messages: [] }];
      currentId = id;
      saveThreads();
    }
    renderSidebar();
    renderMessages();
  </script>
</body>
</html>
